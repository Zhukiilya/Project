1) Есть два человека - отправитель и получатель. Отправитель хочет отправить свое 
сообщение получателю, при этом он хочет, чтобы никто не узнал о содержании сообщения,
кроме отправителя, чтобы никто не мог видоизменить его "письмо".
2) Формирование общего ключа для симметричного шифрования в соответствии со стандартом RFC8731.
Для формирования общего ключа рекомендуется исползовать ECDH (Elliptic Curve Diffy Hellman). 
В соответствии со стандартом RFC8418(Use of the Elliptic Curve Diffie-Hellman Key Agreement Algorithmwith X25519 and X448 in the Cryptographic Message Syntax (CMS)) для формирования общего ключа используется алгоритм X25519, использующий эллиптическую кривую Curve25519 разработанную всемирно известным программистом Даниелем Бернштейном. 
Уравнение эллиптической кривой Curve25519: y² = (x³ + 486662x² + x )mod(2^255 – 19) 
    1. Отправитель и получатель выбирают себе приватные ключи d_a и d_b соответсвенно с помощью
       криптографически стойкого генератора псевдослучайных чисел/генератора истинно случайных чисел, генерирующих 
       непредсказуемое псевдослучайное число длиною 256 бит. После генерации приватных ключей они "маскируются" таким 
       образом, чтобы каждый приватный ключ входил в диапозон [2^254, 2^255). Маскированный d_a - приватный ключ 
       отправителя. Маскированный d_b - приватный ключ получателя.
    2.1 Отправитель формирует свой публичный ключ скалярно умножая маскированный d_a на точку G с помощью алгоритма 
        "лестница Монтгомери", позволяющего находить x-координаты новых точек на эллиптической кривой при скалярном 
        умножении не используя Y-координаты. G - точка на эллиптической кривой с координатой x равной 9. 
        Результат скалярного умножения с помощью "лестницы Монтгомери" - и есть публичный ключ отправителя. 
        Будем называть публичным ключом отправителя параметр P_ax.
    2.2 Аналогичным образом получает свой публичный ключ получатель сообщения (в скалярном умножении вместо 
        d_a используется d_b). Будем называть публичным ключом получателя параметр P_bx.
    Примечания:
    Размер d = размер публичного ключа = 32 байта. 
    3. Обмен публичными ключами происходит по двум защищенным каналам. Обмен публичными ключами продолжается 
       по паре защищенных каналов до тех пор, пока публичные ключи не совпадут во всех каналах. В случае, если 
       публичные ключи не совпадают в этой паре каналов, обмен публичными ключами происходит повторно по этим же 
       каналам. Вместе с публичными ключами также передаются случайные 32 байта, которые будут впоследствии ukm 
       для функции формирования ключа (KDF). 
    4. В соответсвии с другим всемирно известным стандартом NIST SP 800-56A rev.3 необходимо провести проверку 
       публичных ключей на стороне отправителя и получателя. В случае, если у отправителя или получателя публичный 
       ключ окажется размера больше 32 байт или окажется равен 0 (проверка на равенство 0 происходит с помощью 
       побайтового "ИЛИ", чтобы избежать атак по времени), обмен публичными ключами должен будет произойти 
       повторно по этим же каналам.
    5.1 После обмена публичными ключами отправитель умножает скалярно d_a (приватный ключ отправителя)
        на публичный ключ P_bx используя алгоритм "лестница Монтгомери". Найденная x-координата точки в 
        результате скалярного умножения - и есть общий секрет K_x.
    5.2 После обмена публичными ключами получатель умножает скалярно d_b (приватный ключ отправителя)
        на публичный ключ P_ba используя алгоритм "лестница Монтгомери". Найденная x-координата точки в 
        результате скалярного умножения - и есть общий секрет K_x.
    Этап 5 формульно: 
        K_a_x = x(P_b*d_a(masked)) = x((d_b(masked)*G)*d_a(masked)) = x((d_b(masked)*d_a(masked))*G) 
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
        K_a_x = x(P_a*d_b(masked)) = x((d_a(masked)*G)*d_b(masked)) = x((d_b(masked)*d_a(masked))*G)
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
    Вывод по этапам 1-5: 
        1. Злоумышленник, зная только G и публичные ключи, не может вычислить приватные ключи, т.к 
        задача, которую ему надо решить, называется ECDLP (Elliptic Curve Discrete Logarithm Problem). Для ее решения 
        с помощью новейших квантовых компьютеров злоумышленнику понадобятся миллиарды лет.
        2. Злоумышленник, зная только d_a*G и d_b*G для того, чтобы узнать K = (d_b*d_a)*G должен также решить 
        Elliptic Curve Discrete Logarithm Problem, что займет у него миллиарды лет ввиду. Сама кривая имеет стойкость 
        в 128 бит. Сложность Elliptic Curve Discrete Logarithm Problem подтверждена NIST SP 800-18B.
        3. Т.к K_a_x = K_b_x = x((d_b(masked)*d_a(masked))*G)=K_x отправитель и получатель получили неизвестный 
        злоумышленнику общий секрет стойкостью 128 бит[RFC7748].
    6. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8418, необходимо провести проверку 
       общего секрета на стороне отправителя и получателя. В случае, если у отправителя или получателя общий секрет 
       окажется строкой нулей, алгоритм ECDH нужно будет исполнить заново ввиду вмешательства злоумышленника. Во 
       избежание атак по времени проверка общего секрета происходит с помощью побайтового "ИЛИ", которое выполняется 
       константное время. После получения общих секретов приватные и публичные ключи, удаляются в соответсвии со
       стандартом RFC8418.
    7. В соответсвии со стандартом RFC8418, в случае прохождения проверки для получения ключа для симметричного 
       шифрования из общего секрета K_x, необходимо использовать KDF (KEY Derivation Function), которая добавляет 
       уникальности ключу и усложняет возможность проведения атак. Одной из одобренных KDF является двухэтапная (с 
       фазой извлечения и расширения) HMAC-based Key Derivation Function (HKDF) HKDF-SHA256(salt, K_x, info, 
       len_bytes). В качестве salt используется ukm? который есть в наличии у обоих абонентов, в качестве info в
       соответствии со стандартом RFC8418 info ::= SEQUENCE {
        keyInfo         AlgorithmIdentifier,
        entityUInfo [0] EXPLICIT OCTET STRING OPTIONAL,
        suppPubInfo [2] EXPLICIT OCTET STRING  }.
3) Получив общий ключ (необходимые инициализирующие значения для ГПСЧ) отправитель теперь может зашифровать свое сообщение сложив методом XOR открытый текст с гаммой, которую генерирует ГПСЧ; получатель сможет расшифровать сообщение сложив методом XOR гамму с шифрованным текстом. Гаммы, генерируемы ГПСЧ на стороне отправителя и 
получателя будут одинаковые за счет одинаковых инициализирующих значений, сгенерированных раннее алгориитмом ECDH.
