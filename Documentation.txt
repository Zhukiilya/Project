1) Есть два человека - отправитель и получатель. Отправитель хочет отправить свое 
сообщение получателю, при этом он хочет, чтобы никто не узнал о содержании сообщения,
кроме отправителя, чтобы никто не мог видоизменить его "письмо".
2) Формирование общего ключа для симметричного шифрования в соответствии со стандартом RFC8731.
Для формирования общего ключа рекомендуется исползовать ECDH (Elliptic Curve Diffy Hellman). 
В соответствии со стандартом RFC8418(Use of the Elliptic Curve Diffie-Hellman Key Agreement Algorithmwith X25519 and X448 in the Cryptographic Message Syntax (CMS)) для формирования общего ключа используется алгоритм X25519, использующий эллиптическую кривую Curve25519 разработанную всемирно известным программистом Даниелем Бернштейном. 
Уравнение эллиптической кривой Curve25519: y² = (x³ + 486662x² + x )mod(2^255 – 19) 
    1. Отправитель и получатель выбирают себе приватные ключи d_a и d_b соответсвенно с помощью
       криптографически стойкого генератора псевдослучайных чисел/генератора истинно случайных чисел, генерирующих 
       непредсказуемое псевдослучайное число длиною 256 бит. После генерации приватных ключей они "маскируются" таким 
       образом, чтобы каждый приватный ключ входил в диапозон [2^254, 2^255). Маскированный d_a - приватный ключ 
       отправителя. Маскированный d_b - приватный ключ получателя.
    2.1 Отправитель формирует свой публичный ключ скалярно умножая маскированный d_a на точку G с помощью алгоритма 
        "лестница Монтгомери", позволяющего находить x-координаты новых точек на эллиптической кривой при скалярном 
        умножении не используя Y-координаты. G - точка на эллиптической кривой с координатой x равной 9. 
        Результат скалярного умножения с помощью "лестницы Монтгомери" - и есть публичный ключ отправителя. 
        Будем называть публичным ключом отправителя параметр P_ax.
    2.2 Аналогичным образом получает свой публичный ключ получатель сообщения (в скалярном умножении вместо 
        d_a используется d_b). Будем называть публичным ключом получателя параметр P_bx.
    Примечания:
    Размер d = размер публичного ключа = 32 байта. 
    3. В процессе обмена публичными ключами основная задача - избежать их видоизменения из-за атаки "Человек
       посередине". Для этого необходимо применить цифровую подпись, для которой также необходимо обменяться 
       публичными ключами. Полностью предотвратить вмешательство "Человека посередине" без доверенных центров 
       невозможно, поэтому мы обязаны в этих условиях выявлять его присутствие через многократные проверки с помощью 
       OOB (out of band) каналов и других процедур. Однако после проведения этой долгой проверки нужное количество 
       раз отправитель и получатель обменяются своими публичными ключами для цифровой подписи RSAPSS-4096, что 
       позволит им в последующем общении сразу предупреждать вмешательство человека посередине. На данный момент 
       отсуствуют стандарты, определяющие точное количество OOB каналов для того, чтобы гарантировать невозможность 
       вмешательства злоумышленников государственного уровня хотя бы в одном из них. Однако в соответсвии со 
       стандартом ГОСТ34 необходимо использование разнородных каналов связи для минимизации единой точки отказа
       (необходимость многофакторной аутентификации).
       алгоритм подписи RSASSA-PSS-4096 выбран ввиду необходимости задействовать большее количество ресурсов для 
       корректной замены ключей при вмешательстве злоумышленника. Процедура обмена публичными ключами для цифровой 
       подписи RSASSA-PSS-4096 (с предположением того, что злоумышленник у нас государственного уровня):
           1. Отправитель и получатель генерируют публичные и приватные ключи в соответвствии со стандартом 
              NIST SP 800-56B с помощью взаимно протсых чисел p и q длиной 2048 бит и публичной экспоненты 
              e = 65537. Число n генериуется создается с помощью следующей формулы: p*q
              d создается с помощью следующей формулы: d = (e^-1)mod(p-1)(q-1)
              Тогда публичный ключ отправителя - (n_a, e), приватный ключ отправителя - (n_a, d_a)
              публичный ключ получателя - (n_b, e), приватный ключ получателя - (n_b, d_b)
           2. Отправитель и получатель отправляют по своим e-mail адресам свои публичные ключи n (без e, т.к. 
              e=65537). В соответствии со стандартом RFC8017, подпись вычисляется пос ледующей формуле: S = 
             (Дополнение PSS∥(MGF(Salt) ⊕ Hash(M || Padding1))∥Salt∥Padding)
    4. В соответсвии с другим всемирно известным стандартом NIST SP 800-56A rev.3 необходимо провести проверку 
       публичных ключей на стороне отправителя и получателя. В случае, если у отправителя или получателя публичный 
       ключ окажется размера больше 32 байт или окажется равен 0 (проверка на равенство 0 происходит с помощью 
       побайтового "ИЛИ", чтобы избежать атак по времени), обмен публичными ключами должен будет произойти 
       повторно по этим же каналам.
    5.1 После обмена публичными ключами отправитель умножает скалярно d_a (приватный ключ отправителя)
        на публичный ключ P_bx используя алгоритм "лестница Монтгомери". Найденная x-координата точки в 
        результате скалярного умножения - и есть общий секрет K_x.
    5.2 После обмена публичными ключами получатель умножает скалярно d_b (приватный ключ отправителя)
        на публичный ключ P_ba используя алгоритм "лестница Монтгомери". Найденная x-координата точки в 
        результате скалярного умножения - и есть общий секрет K_x.
    Этап 5 формульно: 
        K_a_x = x(P_b*d_a(masked)) = x((d_b(masked)*G)*d_a(masked)) = x((d_b(masked)*d_a(masked))*G) 
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
        K_a_x = x(P_a*d_b(masked)) = x((d_a(masked)*G)*d_b(masked)) = x((d_b(masked)*d_a(masked))*G)
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
    Вывод по этапам 1-5: 
        1. Злоумышленник, зная только G и публичные ключи, не может вычислить приватные ключи, т.к 
        задача, которую ему надо решить, называется ECDLP (Elliptic Curve Discrete Logarithm Problem). Для ее решения 
        с помощью новейших квантовых компьютеров злоумышленнику понадобятся миллиарды лет.
        2. Злоумышленник, зная только d_a*G и d_b*G для того, чтобы узнать K = (d_b*d_a)*G должен также решить 
        Elliptic Curve Discrete Logarithm Problem, что займет у него миллиарды лет ввиду. Сама кривая имеет стойкость 
        в 128 бит. Сложность Elliptic Curve Discrete Logarithm Problem подтверждена NIST SP 800-18B.
        3. Т.к K_a_x = K_b_x = x((d_b(masked)*d_a(masked))*G)=K_x отправитель и получатель получили неизвестный 
        злоумышленнику общий секрет стойкостью 128 бит[RFC7748].
    6. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8418, необходимо провести проверку 
       общего секрета на стороне отправителя и получателя. В случае, если у отправителя или получателя общий секрет 
       окажется строкой нулей, алгоритм ECDH нужно будет исполнить заново ввиду вмешательства злоумышленника. Во 
       избежание атак по времени проверка общего секрета происходит с помощью побайтового "ИЛИ", которое выполняется 
       константное время. После получения общих секретов приватные и публичные ключи, удаляются в соответсвии со
       стандартом RFC8418.
    7. В соответсвии со стандартом RFC8418, в случае прохождения проверки для получения ключа для симметричного 
       шифрования из общего секрета K_x, необходимо использовать KDF (KEY Derivation Function), которая добавляет 
       уникальности ключу и усложняет возможность проведения атак. Одной из одобренных KDF является двухэтапная (с 
       фазой извлечения и расширения) HMAC-based Key Derivation Function (HKDF) HKDF-SHA256(salt, K_x, info, 
       len_bytes). В качестве salt используется ukm? который есть в наличии у обоих абонентов, в качестве info в
       соответствии со стандартом RFC8418 info ::= SEQUENCE {
        keyInfo         AlgorithmIdentifier,
        entityUInfo [0] EXPLICIT OCTET STRING OPTIONAL,
        suppPubInfo [2] EXPLICIT OCTET STRING  }.
3) Шифрование и расшифрование сообщений, обеспечение его целостнотсти с помощью цифровой подписи.
    1. Получив общий ключ (необходимые инициализирующие значения для ГПСЧ) отправитель теперь шифрует свое сообщение 
       сложив методом XOR открытый текст с гаммой, которую генерирует ГПСЧ. В сооответствии со стандартом отправитель 
       подписывает свое сообщение используя свой приватный ключ для по следующей формуле: 
    2. Получатель проверяет подпись используя публичный ключ отправителя сможет расшифровать сообщение сложив методом XOR гамму с шифрованным текстом. Гаммы, генерируемы ГПСЧ на стороне отправителя и 
получателя будут одинаковые за счет одинаковых инициализирующих значений, сгенерированных раннее алгориитмом ECDH.
