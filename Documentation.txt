1) Есть два человека - отправитель и получатель. Отправитель хочет отправить свое сообщение получателю, при этом он хочет, чтобы никто не узнал о содержании сообщения, кроме отправителя, чтобы никто не мог видоизменить его "письмо".
2) Формирование общего ключа для симметричного шифрования в соответствии со стандартом RFC8731. Для формирования общего ключа рекомендуется исползовать ECDH (Elliptic Curve Diffy Hellman). В соответствии со стандартом RFC8418(Use of the Elliptic Curve Diffie-Hellman Key Agreement Algorithmwith X25519 and X448 in the Cryptographic Message Syntax (CMS)) для формирования общего ключа используется алгоритм X25519, использующий эллиптическую кривую Curve25519 разработанную всемирно известным программистом Даниелем Бернcтайном. Уравнение эллиптической кривой Curve25519: y² = (x³ + 486662x² + x )mod(2^255 – 19) 
    1. Отправитель и получатель выбирают себе приватные ключи d_a и d_b соответсвенно с помощью криптографически стойкого генератора псевдослучайных чисел/генератора 
       истинно случайных чисел, генерирующих непредсказуемое псевдослучайное число длиною 256 бит. После генерации приватных ключей они "маскируются" таким 
       образом, чтобы каждый приватный ключ входил в диапозон [2^254, 2^255). Маскированный d_a - приватный ключ отправителя. Маскированный d_b - приватный ключ 
       получателя. 
       Реализация на Python: d_a = X25519PrivateKey.generate(); d_b = = X25519PrivateKey.generate()
    2.1 Отправитель формирует свой публичный ключ скалярно умножая маскированный d_a на точку G с помощью алгоритма "лестница Монтгомери", позволяющего 
        находить x-координаты новых точек на эллиптической кривой при скалярном умножении не используя Y-координаты. G - точка на эллиптической кривой с координатой 
        x равной 9. Результат скалярного умножения с помощью "лестницы Монтгомери" - и есть публичный ключ отправителя. Будем называть публичным ключом отправителя 
        параметр P_ax.
        Реализация на Python: P_ax = d_a.public_key()
    2.2 Аналогичным образом получает свой публичный ключ получатель сообщения (в скалярном умножении вместо d_a используется d_b). Будем называть публичным ключом 
        получателя параметр P_bx.
        Реализация на Python: P_bx = d_b.public_key()
    Примечания:
    Размер d = размер публичного ключа = 32 байта. 
    0. В процессе обмена публичными ключами основная задача - избежать их видоизменения из-за атаки "Человек посередине". Для этого необходимо применить цифровую 
       подпись, для которой также необходимо обменяться публичными ключами. Полностью предотвратить вмешательство "Человека посередине" без доверенных центров 
       невозможно, поэтому мы обязаны в этих условиях выявлять его присутствие через многократные проверки с помощью OOB (out of band) каналов и других процедур. 
       Однако после проведения этой долгой проверки нужное количество раз отправитель и получатель обменяются своими публичными ключами для цифровой подписи 
       RSASSA-PSS-4096, что позволит им в последующем общении сразу предупреждать вмешательство человека посередине. На данный момент отсуствуют стандарты, 
       определяющие точное количество OOB каналов для того, чтобы гарантировать невозможность вмешательства злоумышленников государственного уровня хотя бы в одном 
       из них. Однако в соответсвии со стандартом ГОСТ34, а также стандартам NIST SP 800-63 необходимо использование разнородных каналов связи для минимизации единой 
       точки отказа (необходимость многофакторной аутентификации).
       алгоритм подписи RSASSA-PSS-4096 выбран ввиду необходимости задействовать большее количество ресурсов для 
       корректной замены ключей при вмешательстве злоумышленника. Процедура обмена публичными ключами для цифровой 
       подписи RSASSA-PSS-4096 (с предположением того, что злоумышленник у нас высокого уровня):
           1.. Отправитель и получатель генерируют публичные и приватные ключи в соответвствии со стандартом NIST SP 800-56B с помощью взаимно протсых чисел p и q 
               длиной 2048 бит и публичной экспоненты e = 65537. Число n генериуется создается с помощью следующей формулы: p*q 
              d создается с помощью следующей формулы: d = (e^-1)mod(p-1)(q-1)
              Тогда публичный ключ отправителя - (n_ae, e), приватный ключ отправителя - (n_ae, d_ae)
              Реализация на Python:
                 private_rsa_key_a = rsa.generate_private_key(public_exponent=65537, key_size=4096, backend=default_backend())   
                 public_rsa_key_a = private_rsa_key_a.public_key()
              публичный ключ получателя - (n_be, e), приватный ключ получателя - (n_be, d_be)
              Реализация на Python: 
                 private_rsa_key_b = rsa.generate_private_key(public_exponent=65537, key_size=4096, backend=default_backend())   
                 public_rsa_key_b = private_rsa_key_b.public_key()
           2.. Отправитель и получатель отправляют по своим e-mail адресам свои публичные ключи n (без e, т.к. e=65537). В соответствии со стандартом RFC8017, 
               подпись для каждого из числа n вычисляется по следующей формуле: S = [(DB ⊕ dbMask) || H || 0xbc]^d mod n, где:
                   H = SHA-256(0x00 00 00 00 00 00 00 00 || SHA-256(n) || salt)
                   DB = PS || 0x01 || salt, в котором PS - 446 нулевых байт
                   dbMask = MGF-SHA256(H, 479), в которой MGF-SHA256 - функция генерации маски на основе хэш-функции SHA-256
               Сама процедура дополнения нужна для того, чтобы каждое сообщение было уникальным, что предотвращает атаки, основанные на повторном использовании 
               подписей или анализе подписей для одинаковых сообщений. Предположим, злоумышленник получает доступ к защищенному каналу и видоизменяет сообщения так, 
               как ему надо. Хороший злоумышленник подберет свой публичный ключ n,таким образом, что проверка подписи с помощью его публичного ключа будет корректной.
               Реализация для отправителя: n_ae_bytes = n_ae.to_bytes((n.bit_length() + 7) // 8, byteorder="big")
               S_a = private_rsa_key_a.sign(n_ae_bytes, padding=padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32), algorithm=hashes.SHA256()) 
               Реализация для получателя: n_be_bytes = n_be.to_bytes((n.bit_length() + 7) // 8, byteorder="big") 
               S_b = private_rsa_key_b.sign(n_be_bytes, padding=padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32), algorithm=hashes.SHA256())
           3.. На случай плохих злоумышленников отправитель и получатель сначала сравнивают длинну подписи S, а также длину самого сообщения в соответвствии со 
               стандартом RFC8017 (оба параметра должна быть длиною 512 байт). На случай плохих злоумышленников также проводится проверка подписи с использованием 
               полученного ключа n с помощью следующего алгоритма: 
                  1... Вычисляется S' по формуле: S' = S^e mod n. S' должно быть длины 512Б
                  2... S' должен иметь следующую структуру: 
                      (DB' ⊕ dbMask') || SHA-256(0x00 00 00 00 00 00 00 00 || SHA-256(n') || salt') || 0xbc
                      если последний байт S' != 0xbc, то присутствие сзлоумышленника раскрывается
                  3... Получатель публичного ключа извлекает SHA-256(0x00 00 00 00 00 00 00 00∥SHA-256(n')∥salt')-(480-511байты s')
                       Будем называть извлеченную часть H'
                  4... Получатель публичного ключа генерирует маску MGF-SHA256(H', 479)
                  5... Получатель публичного ключа извлекает первые 479 байт S' и ксорит их с полученной маской, получая блок 
                       данных DB'. Формульно DB' = (DB' ⊕ dbMask')⊕dbMask' = DB' ⊕ (dbMask'⊕dbMask') = DB' ⊕ 0 = DB'
                       В случае, если первые 446 байт DB' не являются нулевыми, вмешательство злоумышленника обнаруживается.
                       В случае, если 447 байт DB' не является 0x01, вмешательство злоумышленника обнаруживается.
                  6... В случае, если проверка пройдена, из DB' извлекаются последние 32 байта, которые будут
                       являться salt'.
                  7... Получатель публичного ключа вычисляет SHA-256(0x00 00 00 00 00 00 00 00∥SHA-256(n)∥salt'). (n нам прилагается 
                       в сообщении).  Будем называть вычисленный дайджест H''. Если H'' = H', то n соответсвует подписи, если нет - присутсвие 
                       "плохого злоумышленника" раскрывается.
                  Реализация на Python:
                     #отправка подписанных n по e-mail:
                     #сверяем подпись
            4.. Если наш злоумышленник высокого уровня, то скорее всего он подменит часть публичного ключа n и подпись корректно. После проверки подписи у 
                отправителя и получателя окажутся "ложные" части публичных ключей: n_bm и n_am соответсвенно.
            5.. Для того, чтобы выявить атаку "человек посередине" необходимо сверить коды безопасности по нескольким OOB каналам в соответствии со стандартами NIST 
                SP 800-63. Формула кода безопасности: SHA-256(P_a||P_b). Так как отправитель и получатель на данный момент обладают поддельными публичными
                ключами P_bm и P_am их коды безопасности скорее всего не совпадут хотя бы в одном OOB канале (даже злоумышленники высокого уровня с ничтожно 
                малой веротятностью смогут во время отправки сообщений по нескольким OOB каналов взломать каждый из них), что приведет к раскрытию действий 
                злоумышленника, т.к  SHA-256(P_a||P_bm) != SHA-256(P_am||P_b). При обмене кодами безопасности задействуются следующие OOB каналы: новые адреса 
                электронной почты, свой созданный телеграмм бот для обмена сообщениями (по хорошему лучше также сверить коды безопасности по видеосвязи в любом 
                мессенджере, тогда будет обеспечен максимальнай шанс выявления человека посередине). 
                Код безопасности также отправляется по уже взломанному каналу, для того, чтобы задействовать больше сил у злоумышленника.
            Итог: В случае непрохождения этапов этой проверки (выявления присутствия злоумышленника), отправитель и получатель должны сменить адреса электронной 
                  почты, при этом оставив OOB каналы неизменными, и попытаться обменяться повторно публичными ключами и повторно провести описанную выше проверку.
                  В случае, если коды безопасности не совпадут в OOB каналах и во второй раз, отправителю и получателю также придется сменить OOB каналы и завести 
                  новые адреса почты. Как только коды безопасности совпадут во всех OOB каналах отправитель и получатель обменяются публичными ключами для цифровой 
                  подписи, что позволит им сразу выявлять злоумышленника без прохождения вышеописанной проверки и обмена кодами безопасности.
           Примечания: Проверки на длину, последние ненулевые байты должны выполняться за константное время, чтобы избежать атак по времени.
           Почему нам нужно выявления злоумышленника с помощью таких долгих проверок, почему при несовпадении подписей/проверок мы должны сменить адреса электронной 
           почты(в случае несовпадения кодов безопасности) или сменить пароли аккаунтов gmail(в случае несовпадения текста сообщения с подписью после обмена 
           публичными ключами для подписи)? - Злоумышленнику экономически невыгодно взламывать тех, кто обнаруживает его присутствие. Пользователем легче сменить 
           адреса электронной или пароли, чем злоумышленнику взламывать раз за разом защищенные каналы.
    4. Обменявшись публичными ключами для цифровой подписи RSASSA-PSS-4096, теперь отправитель и получатель могут безопасно обменяться по e-mail своими публичными 
       ключами P_ax и P_bx соответственно, подписав их своими приватными ключами для цифровой подписи RSASSA-PSS-4096 соответственно. Вместе со своим публичным 
       ключом отправитель также передаст ukm, или salt2 - случайные 32 байта, которые будут использоваться при генерации ключа.
    5. В соответсвии с другим всемирно известным стандартом NIST SP 800-56A rev.3 необходимо провести проверку публичных ключей (P_ax и P_bx) на стороне отправителя 
       и получателя. Они проверяют их с помощью проверки цифровой подписи RSASSA-PSS-4096 по процедуре, описанной раннее, с использованием полученных раннее 
       публичных ключей (n_a и n_b). В случае, если у отправителя или получателя публичный ключ окажется размера больше 32 байт или окажется равен 0 (проверка на 
       равенство 0 происходит с помощью побайтового "ИЛИ", чтобы избежать атак по времени), или проверка цифровой подписи окажется не пройдена, обмен публичными 
       ключами должен будет произойти повторно по этим же каналам. Если при повторном обмене по этому же каналу повторная проверка публичных ключей окажется не 
       пройдена, то придется все таки еще раз сменить адреса e-mail, для повторного проведения проверки полученных публичных ключей (P_ax и P_bx) по новым адресам
       e-mail. В случае, если и в новых адресах e-mail публичные ключи не пройдут проверку, то придется выполнить всю инструкцию повторно.
    6.1 После обмена публичными ключами отправитель умножает скалярно d_a (приватный ключ отправителя) на публичный ключ P_bx используя алгоритм "лестница 
        Монтгомери". Найденная x-координата точки в результате скалярного умножения - и есть общий секрет K_x.
    6.2 После обмена публичными ключами получатель умножает скалярно d_b (приватный ключ получателя) на публичный ключ P_ba используя алгоритм "лестница 
        Монтгомери". Найденная x-координата точки в результате скалярного умножения - и есть общий секрет K_x.
    Этап 6 формульно: 
        K_a_x = x(P_b*d_a(masked)) = x((d_b(masked)*G)*d_a(masked)) = x((d_b(masked)*d_a(masked))*G) 
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
        K_a_x = x(P_a*d_b(masked)) = x((d_a(masked)*G)*d_b(masked)) = x((d_b(masked)*d_a(masked))*G)
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
    Вывод по этапам 1-5: 
        1. Злоумышленник, зная только G и публичные ключи, не может вычислить приватные ключи, т.к задача, которую ему надо решить, называется 
           ECDLP (Elliptic Curve Discrete Logarithm Problem). Для ее решения с помощью новейших квантовых компьютеров злоумышленнику понадобятся миллиарды лет.
        2. Злоумышленник, зная только d_a*G и d_b*G для того, чтобы узнать K = (d_b*d_a)*G должен также решить Elliptic Curve Discrete Logarithm Problem, что займет 
           у него миллиарды лет ввиду стойкости кривой в 128 бит[RFC7748]. Сложность Elliptic Curve Discrete Logarithm Problem подтверждена NIST SP 800-18B.
        3. Т.к K_a_x = K_b_x = x((d_b(masked)*d_a(masked))*G)=K_x отправитель и получатель получили неизвестный злоумышленнику общий секрет стойкостью 
           128 бит[RFC7748].
    7. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8418, необходимо провести проверку общего секрета на стороне отправителя и получателя. 
       В случае, если у отправителя или получателя общий секрет окажется строкой нулей, алгоритм ECDH нужно будет исполнить заново ввиду вмешательства 
       злоумышленника. Во избежание атак по времени проверка общего секрета происходит с помощью побайтового "ИЛИ", которое выполняется константное время. После b 
       получения общих секретов приватные и публичные ключи, удаляются в соответсвии со стандартом RFC8418.
    8. В соответсвии со стандартом RFC8418, в случае прохождения проверки для получения ключа для симметричного шифрования из общего секрета K_x, необходимо 
       использовать KDF (KEY Derivation Function), которая добавляет уникальности ключу и усложняет возможность проведения атак. Одной из одобренных KDF является 
       двухэтапная (с фазой извлечения и расширения) HMAC-based Key Derivation Function (HKDF) HKDF-SHA256(salt, K_x, info, len_bytes). В качестве salt используется 
       ukm, который есть в наличии у обоих абонентов, в качестве info в соответствии со стандартом RFC8418 используется SEQUENCE {
        keyInfo      { algorithm: 2.16.840.1.101.3.4.1.45, parameters: NULL },
        ukm [0] EXPLICIT OCTET STRING OPTIONAL,
        0x00000100 [2] EXPLICIT OCTET STRING  }. Будем называть вычисленный общий ключ с помощью HKDF параметром K_f.
3) Шифрование и расшифрование сообщений, обеспечение его целостнотсти.
    1.1 Получив K_f отправитель теперь случайно генерирует 12 байт, которые будут являться nonce, после чего с помощью ГПСЧ на основе алгоритма AES-256-CTR, 
        принимающего на вход nonce и K_f, генерирует ключевой поток нужной длины. 
    1.2 Отправитель складывает методом XOR ключевой поток с открытым текстом, получая шифротекст.
    1.3 Отправитель в соответствии с NISTпосле чего добавляет аутентификационный тэг к сообщению, вычисляющийся следующим 
        образом: Tag = GHASH(AES-256-Encrypt(K_f,0x00000000000000000000000000000000),
                 SHA-256(n_a||n_b)||Шифротекст||0x0000000000000100||len(Шифротекст))⊕AES-256-Encrypt(K_f, nonce||0x00000001)
    2. Получатель проверяет тэг по той же формуле. Заметим, что если в самом начале обмен публичными ключами для цифровой подписи был скромпоментирован, то тэг не 
       совпадет. В случае, если тэг не совпадет, отправитель должен будет отправить сообщение повторно по этому же каналу. В случае, если тэг не совпадет и во второй 
       раз, то отправитель должен будет сменить адрес электронной почты и отправить сообщение повторно. В случае, если и по новому каналу проверка тэга не будет 
       пройдена, то это означает, что еще в самом начале обмен публичными ключами был скомпроментирован, из-за чего отправителю и получателю придется повторно 
       выполнить все шаги инструкции.
       В случае, если тэг пройдет проверку, то получатель складывает методом XOR ключевой поток, который генерирует ГПСЧ на основе AES-256-CTR(K_f, nonce) и получает 
       открытый текст.
Особо важное примечание: все случайные параметры должны быть сгенерированы с помощью криптостойкого ГПСЧ, который должен пройти тесты NIST SP 800-90A. os.urandom(), используемый в cryptography, соответсвует стандартам NIST SP 800-90A. 
