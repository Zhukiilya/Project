1) Есть два человека - отправитель и получатель. Отправитель хочет отправить свое 
сообщение получателю, при этом он хочет, чтобы никто не узнал о содержании сообщения,
кроме отправителя, чтобы никто не мог видоизменить его "письмо".
2) Формирование общего ключа для симметричного шифрования в соответствии со стандартом RFC8731.
Для формирования общего ключа рекомендуется исползовать ECDH (Elliptic Curve Diffy Hellman). 
В соответствии со стандартом RFC8731 используется алгоритм X25519, использующий эллиптическую кривую Curve25519 разработанную всемирно известным программистом Даниелем Бернштейном. 
Уравнение эллиптической кривой Curve25519: y² = (x³ + 486662x² + x )mod(2^255 – 19) 
    1. Отправитель и получатель выбирают себе приватные ключи d_a и d_b соответсвенно с помощью
       криптографически стойкого генератора псевдослучайных чисел/генератора истинно случайных чисел, генерирующих 
       непредсказуемое псевдослучайное число длиною 256 бит. После генерации приватных ключей они "маскируются" таким 
       образом, чтобы каждый приватный ключ входил в диапозон [2^254, 2^255). Маскированный d_a - приватный ключ 
       отправителя. Маскированный d_b - приватный ключ получателя.
    2.1 Отправитель формирует свой публичный ключ скалярно умножая маскированный d_a на точку G с помощью алгоритма 
        "лестница Монтгомери", позволяющего находить x-координаты новых точек на эллиптической кривой при скалярном 
        умножении не используя Y-координаты. G - точка на эллиптической кривой с координатой x равной 9. 
        Результат скалярного умножения с помощью "лестницы Монтгомери" - и есть публичный ключ отправителя. 
        Будем называть публичным ключом отправителя параметр P_ax.
    2.2 Аналогичным образом получает свой публичный ключ получатель сообщения (в скалярном умножении вместо 
        d_a используется d_b). Будем называть публичным ключом получателя параметр P_bx.
    Примечания:
    Размер d = размер публичного ключа = 32 байта. 
    3. Обмен публичными ключами
    4. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8731, необходимо провести проверку 
       публичных на стороне отправителя и получателя. В случае, если у отправителя или получателя публичный ключ 
       окажется размера больше 32 байт, обмен публичными ключами должен будет произойти повторно по новым каналам.
    5.1 После обмена публичными ключами отправитель умножает скалярно d_a (приватный ключ отправителя)
        на публичный ключ P_bx используя алгоритм "лестница Монтгомери". Найденная x-координата точки в 
        результате скалярного умножения - и есть общий секрет S_x.
    5.2 После обмена публичными ключами получатель умножает скалярно d_b (приватный ключ отправителя)
        на публичный ключ P_ba используя алгоритм "лестница Монтгомери". Найденная x-координата точки в 
        результате скалярного умножения - и есть общий секрет.
    Этап 5 формульно: 
        S_a_x = x(P_b*d_a(masked)) = x((d_b(masked)*G)*d_a(masked)) = x((d_b(masked)*d_a(masked))*G) 
        S_a_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
        S_b_x = x(P_a*d_b(masked)) = x((d_a(masked)*G)*d_b(masked)) = x((d_b(masked)*d_a(masked))*G)
        S_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
    Вывод по этапам 1-5: 
        1. Злоумышленник, зная только G и публичные ключи, не может вычислить приватные ключи, т.к 
        задача, которую ему надо решить, называется ECDLP (Elliptic Curve Discrete Logarithm Problem). Для ее решения 
        с помощью новейших квантовых компьютеров злоумышленнику понадобятся миллиарды лет.
        2. Злоумышленник, зная только d_a*G и d_b*G для того, чтобы узнать S = (d_b*d_a)*G должен также решить 
        Elliptic Curve Discrete Logarithm Problem, что займет у него миллиарды лет. 
        Сложность Elliptic Curve Discrete Logarithm Problem подтверждена NIST SP 800-186.
        3. Т.к S_a_x = S_b_x = x((d_b(masked)*d_a(masked))*G)=S_x отправитель и получатель получили неизвестный 
        злоумышленнику общий секрет.
    6. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8731, необходимо провести проверку 
       общего секрета на стороне отправителя и получателя. В случае, если у отправителя или получателя общий секрет 
       окажется строкой нулей, алгоритм ECDH нужно будет заново исполнить ввиду вмешательства злоумышленника. Во 
       избежание атак по времени проверка общего секрета происходит с помощью побайтового "ИЛИ".
    7. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8731, в случае прохождения проверки 
       для получения ключа для симметричного шифрования из общего секрета S_x, который имеет криптографическую 
       стойкость в 251 бит ввиду маскирования необходимо использовать KDF (KEY Derivation Function), которая 
       повысит его стойкость до 256 бит. Одобренные KEY Derivation Functions представлены в стандарте 
       NIST SP 800-56C revision 2. В разработанном ПО используется одобренная стандартом одношаговая KDF HMAC- 
       SHA256(salt, x), где x - общий секрет S_x. В соответсвии с NIST SP 800-56C revision 2 для максимального 
       повышения безопасности при использовании одношаговой KDF salt должна быть секретной, 
       известной отправителю и получателю, длиною
3) Получив общий ключ (необходимые инициализирующие значения для ГПСЧ) отправитель теперь может зашифровать свое сообщение сложив методом XOR открытый текст с гаммой, которую генерирует ГПСЧ; получатель сможет расшифровать сообщение сложив методом XOR гамму с шифрованным текстом. Гаммы, генерируемы ГПСЧ на стороне отправителя и 
получателя будут одинаковые за счет одинаковых инициализирующих значений, сгенерированных раннее алгориитмом ECDH.
