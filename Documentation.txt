1) Есть два человека - отправитель и получатель. Отправитель хочет отправить свое 
сообщение получателю, при этом он хочет, чтобы никто не узнал о содержании сообщения,
кроме отправителя, чтобы никто не мог видоизменить его "письмо".
2) Формирование общего ключа для симметричного шифрования в соответствии со стандартом RFC8731. Для формирования общего ключа рекомендуется исползовать ECDH (Elliptic Curve Diffy Hellman). В соответствии со стандартом RFC8418(Use of the Elliptic Curve Diffie-Hellman Key Agreement Algorithmwith X25519 and X448 in the Cryptographic Message Syntax (CMS)) для формирования общего ключа используется алгоритм X25519, использующий эллиптическую кривую Curve25519 разработанную всемирно известным программистом Даниелем Бернcтайном. Уравнение эллиптической кривой Curve25519: y² = (x³ + 486662x² + x )mod(2^255 – 19) 
    1. Отправитель и получатель выбирают себе приватные ключи d_a и d_b соответсвенно с помощью криптографически стойкого генератора псевдослучайных чисел/генератора 
       истинно случайных чисел, генерирующих непредсказуемое псевдослучайное число длиною 256 бит. После генерации приватных ключей они "маскируются" таким 
       образом, чтобы каждый приватный ключ входил в диапозон [2^254, 2^255). Маскированный d_a - приватный ключ отправителя. Маскированный d_b - приватный ключ 
       получателя. 
    2.1 Отправитель формирует свой публичный ключ скалярно умножая маскированный d_a на точку G с помощью алгоритма "лестница Монтгомери", позволяющего 
        находить x-координаты новых точек на эллиптической кривой при скалярном умножении не используя Y-координаты. G - точка на эллиптической кривой с координатой 
        x равной 9. Результат скалярного умножения с помощью "лестницы Монтгомери" - и есть публичный ключ отправителя. Будем называть публичным ключом отправителя 
        параметр P_ax.
    2.2 Аналогичным образом получает свой публичный ключ получатель сообщения (в скалярном умножении вместо d_a используется d_b). Будем называть публичным ключом 
        получателя параметр P_bx.
    Примечания:
    Размер d = размер публичного ключа = 32 байта. 
    3. В процессе обмена публичными ключами основная задача - избежать их видоизменения из-за атаки "Человек посередине". Для этого необходимо применить цифровую 
       подпись, для которой также необходимо обменяться публичными ключами. Полностью предотвратить вмешательство "Человека посередине" без доверенных центров 
       невозможно, поэтому мы обязаны в этих условиях выявлять его присутствие через многократные проверки с помощью OOB (out of band) каналов и других процедур. 
       Однако после проведения этой долгой проверки нужное количество раз отправитель и получатель обменяются своими публичными ключами для цифровой подписи 
       RSASSA-PSS-4096, что позволит им в последующем общении сразу предупреждать вмешательство человека посередине. На данный момент отсуствуют стандарты, 
       определяющие точное количество OOB каналов для того, чтобы гарантировать невозможность вмешательства злоумышленников государственного уровня хотя бы в одном 
       из них. Однако в соответсвии со стандартом ГОСТ34, а также стандартам NIST SP 800-63 необходимо использование разнородных каналов связи для минимизации единой 
       точки отказа (необходимость многофакторной аутентификации).
       алгоритм подписи RSASSA-PSS-4096 выбран ввиду необходимости задействовать большее количество ресурсов для 
       корректной замены ключей при вмешательстве злоумышленника. Процедура обмена публичными ключами для цифровой 
       подписи RSASSA-PSS-4096 (с предположением того, что злоумышленник у нас государственного уровня):
           1.. Отправитель и получатель генерируют публичные и приватные ключи в соответвствии со стандартом NIST SP 800-56B с помощью взаимно протсых чисел p и q 
               длиной 2048 бит и публичной экспоненты e = 65537. Число n генериуется создается с помощью следующей формулы: p*q 
              d создается с помощью следующей формулы: d = (e^-1)mod(p-1)(q-1)
              Тогда публичный ключ отправителя - (n_a, e), приватный ключ отправителя - (n_a, d_a)
              публичный ключ получателя - (n_b, e), приватный ключ получателя - (n_b, d_b)
           2.. Отправитель и получатель отправляют по своим e-mail адресам свои публичные ключи n (без e, т.к. e=65537). В соответствии со стандартом RFC8017, 
              подпись для каждого из числа n вычисляется по следующей формуле: 
              S=([(Padding2∥salt)⊕MGF-SHA256(SHA-256(Padding1∥SHA256(n)∥salt),479)]∥SHA-256(Padding1∥SHA256(n)∥salt)∥0xbc)^d mod n 
              где Padding1 и Padding2 - нули для выравнивания, salt - случайно сгенерированные 32 байта, MGF-SHA256 - функция генерации маски, n - в нашем случае 
              отправляемый публичный ключ, в других случаях используется M вместо n, где M- отправляемое сообщение. Сама процедура дополнения нужна для того, 
              чтобы каждое сообщение было уникальным, что предотвращает атаки, основанные на повторном использовании подписей или анализе подписей для одинаковых 
              сообщений. Предположим, злоумышленник получает доступ к защищенному каналу и видоизменяет сообщения так, как ему надо. Хороший злоумышленник подберет 
              свой публичный ключ n, таким образом, что проверка подписи с помощью его публичного ключа будет корректной.
           3.. На случай плохих злоумышленников отправитель и получатель сначала сравнивают длинну подписи S в соответвствии со стандартом RFC8017 (она должна быть 
               длиною 512 байт). На случай плохих злоумышленников также проводится проверка подписи с использованием полученного ключа n с помощью следующего 
               алгоритма: 
                  1... Вычисляется дополненное маскированное S' по формуле: S' = S^e mod n. S' должно быть длины 512Б
                  2... S' имеет следующую структуру: 
                      маскированный блок данных||SHA-256(Padding1∥SHA-256(n')∥salt)||0xbc
                      если последний байт S' != 0xbc, то присутствие сзлоумышленника раскрывается
                  3... Получатель публичного ключа извлекает SHA-256(Padding1∥SHA-256(n')∥salt)-(480-511байты s')
                       Будем называть извлеченную часть H'
                  4... Получатель публичного ключа генерирует маску MGF-SHA256(H', 479)
                  5... Получатель публичного ключа извлекает первые 479 байт S' и ксорит их с маской, получая блок 
                       данных DB' = маскированный блок данных ⊕ маска. 
                       В случае, если первые 447 байтов маскированного блока данных не являются нулевыми, вмешательство злоумышленника обнаруживается.
                  6... В случае, если проверка пройдена, из DB' извлекаются последние 32 байта, которые будут
                       являться salt'.
                  7... Получатель публичного ключа вычисляет SHA-256(Padding1∥SHA-256(n)∥salt'). (n нам прилагается 
                       в сообщении).  Будем называть вычисленный дайджест H''. Если H'' = H', то n соответсвует подписи, если нет - присутсвие 
                       "плохого злоумышленника раскрывается".
            4.. Если наш злоумышленник государственного уровня, то скорее всего он подменит часть публичного ключа n и подпись корректно. После проверки подписи у 
                отправителя и получателя окажутся "ложные" части публичных ключей: n_bm и n_am соответсвенно.
            5.. Для того, чтобы выявить атаку "человек посередине" необходимо сверить коды безопасности по нескольким OOB каналам в соответствии со стандартами NIST 
                SP 800-63. Формула кода безопасности: SHA-256(P_a||P_b). Так как отправитель и получатель на данный момент обладают поддельными публичными
                ключами P_bm и P_am их коды безопасности скорее всего не совпадут хотя бы в одном OOB канале (даже злоумышленники государтсвенного уровня с ничтожно 
                малой веротятностью смогут во время отправки сообщений по нескольким OOB каналов взломать каждый из них), что приведет к раскрытию действий 
                злоумышленника, т.к  SHA-256(P_a||P_bm) != SHA-256(P_am||P_b). При обмене кодами безопасности задействуются следующие OOB каналы: новые адреса 
                электронной почты, свой созданный телеграмм бот для обмена сообщениями (по хорошему лучше также сверить коды безопасности по видеосвязи в любом 
                мессенджере, тогда будет обеспечен максимальнай шанс выявления человека посередине). 
                Код безопасности также отправляется по уже взломанному каналу, для того, чтобы задействовать больше сил у злоумышленника.
            Итог: В случае непрохождения этапов этой проверки (выявления присутствия злоумышленника), отправитель и получатель должны сменить адреса электронной 
                  почты, при этом оставив OOB каналы неизменными, и попытаться обменяться повторно публичными ключами и повторно провести описанную выше проверку.
                  В случае, если коды безопасности не совпадут в OOB каналах и во второй раз, отправителю и получателю также придется сменить OOB каналы. Как только 
                  коды безопасности совпадут во всех OOB каналах отправитель и получатель обменяются публичными ключами для цифровой подписи, что позволит им сразу 
                  выявлять злоумышленника без прохождения вышеописанной проверки и обмена кодами безопасности.
           Примечания: Проверки на длину, последние ненулевые байты должны выполняться за константное время, чтобы избежать атак по времени.

           Почему нам нужно выявления злоумышленника с помощью таких долгих проверок, почему при несовпадении подписей/проверок мы должны сменить адреса электронной 
           почты(в случае несовпадения кодов безопасности) или сменить пароли аккаунтов gmail(в случае несовпадения текста сообщения с подписью после обмена 
           публичными ключами для подписи)? - Злоумышленнику экономически невыгодно взламывать тех, кто обнаруживает его присутствие. Пользователем легче сменить 
           адреса электронной или пароли, чем злоумышленнику взламывать раз за разом защищенные каналы.
    4. Обменявшись публичными ключами для цифровой подписи RSASSA-PSS-4096, теперь отправитель и получатель могут безопасно обменяться по e-mail своими публичными 
       ключами P_ax и P_bx соответственно, подписав их своими приватными ключами для цифровой подписи RSASSA-PSS-4096 соответственно. Вместе со своим публичным 
       ключом отправитель также передаст ukm, или salt - случайные 32 байта, которые будут использоваться при генерации ключа.
    5. В соответсвии с другим всемирно известным стандартом NIST SP 800-56A rev.3 необходимо провести проверку публичных ключей (P_ax и P_bx) на стороне отправителя 
       и получателя. Они проверяют их с помощью проверки цифровой подписи RSASSA-PSS-4096 по процедуре, описанной раннее, с использованием полученных раннее 
       публичных ключей (n_a и n_b). В случае, если у отправителя или получателя публичный ключ окажется размера больше 32 байт или окажется равен 0 (проверка на 
       равенство 0 происходит с помощью побайтового "ИЛИ", чтобы избежать атак по времени) или проверка цифровой подписи окажется не пройдена, обмен публичными 
       ключами должен будет произойти повторно по этим же каналам. Если при повторном обмене по этому же каналу повторная проверка публичных ключей окажется не 
       пройдена, то придется все таки еще раз сменить адреса e-mail, для повторного проведения проверки полученных публичных ключей (P_ax и P_bx) по новым адресам
       e-mail.
    6.1 После обмена публичными ключами отправитель умножает скалярно d_a (приватный ключ отправителя) на публичный ключ P_bx используя алгоритм "лестница 
        Монтгомери". Найденная x-координата точки в результате скалярного умножения - и есть общий секрет K_x.
    6.2 После обмена публичными ключами получатель умножает скалярно d_b (приватный ключ отправителя) на публичный ключ P_ba используя алгоритм "лестница 
        Монтгомери". Найденная x-координата точки в результате скалярного умножения - и есть общий секрет K_x.
    Этап 6 формульно: 
        K_a_x = x(P_b*d_a(masked)) = x((d_b(masked)*G)*d_a(masked)) = x((d_b(masked)*d_a(masked))*G) 
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
        K_a_x = x(P_a*d_b(masked)) = x((d_a(masked)*G)*d_b(masked)) = x((d_b(masked)*d_a(masked))*G)
        K_b_x = (скалярное умножение c помощью алгоритма Монтгомери (d_b(masked)*d_a(masked)) на G)
    Вывод по этапам 1-5: 
        1. Злоумышленник, зная только G и публичные ключи, не может вычислить приватные ключи, т.к задача, которую ему надо решить, называется 
           ECDLP (Elliptic Curve Discrete Logarithm Problem). Для ее решения с помощью новейших квантовых компьютеров злоумышленнику понадобятся миллиарды лет.
        2. Злоумышленник, зная только d_a*G и d_b*G для того, чтобы узнать K = (d_b*d_a)*G должен также решить Elliptic Curve Discrete Logarithm Problem, что займет 
           у него миллиарды лет ввиду стойкости кривой в 128 бит[RFC7748]. Сложность Elliptic Curve Discrete Logarithm Problem подтверждена NIST SP 800-18B.
        3. Т.к K_a_x = K_b_x = x((d_b(masked)*d_a(masked))*G)=K_x отправитель и получатель получили неизвестный злоумышленнику общий секрет стойкостью 
           128 бит[RFC7748].
    7. В соответсвии со документом RFC7748, на который ссылается стандарт RFC8418, необходимо провести проверку общего секрета на стороне отправителя и получателя. 
       В случае, если у отправителя или получателя общий секрет окажется строкой нулей, алгоритм ECDH нужно будет исполнить заново ввиду вмешательства 
       злоумышленника. Во избежание атак по времени проверка общего секрета происходит с помощью побайтового "ИЛИ", которое выполняется константное время. После b 
       получения общих секретов приватные и публичные ключи, удаляются в соответсвии со стандартом RFC8418.
    8. В соответсвии со стандартом RFC8418, в случае прохождения проверки для получения ключа для симметричного шифрования из общего секрета K_x, необходимо 
       использовать KDF (KEY Derivation Function), которая добавляет уникальности ключу и усложняет возможность проведения атак. Одной из одобренных KDF является 
       двухэтапная (с фазой извлечения и расширения) HMAC-based Key Derivation Function (HKDF) HKDF-SHA256(salt, K_x, info, len_bytes). В качестве salt используется 
       ukm, который есть в наличии у обоих абонентов, в качестве info в соответствии со стандартом RFC8418 используется SEQUENCE {
        keyInfo      { algorithm: 2.16.840.1.101.3.4.1.45, parameters: NULL },
        ukm [0] EXPLICIT OCTET STRING OPTIONAL,
        0x00000100 [2] EXPLICIT OCTET STRING  }.
3) Шифрование и расшифрование сообщений, обеспечение его целостнотсти с помощью цифровой подписи.
    1. Получив общий ключ (необходимые инициализирующие значения для ГПСЧ) отправитель теперь шифрует свое сообщение 
       сложив методом XOR открытый текст с гаммой, которую генерирует ГПСЧ. В сооответствии со стандартом отправитель 
       подписывает свое сообщение с помощью RSASSA-PSS-4096 используя свой приватный ключ по раннее описанной 
       формуле.
    2. Получатель проверяет подпись используя публичный ключ отправителя сможет расшифровать сообщение сложив методом XOR гамму с шифрованным текстом. Гаммы, генерируемы ГПСЧ на стороне отправителя и 
получателя будут одинаковые за счет одинаковых инициализирующих значений, сгенерированных раннее алгориитмом ECDH.
